from typing import Any, List

from bson import ObjectId
from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    ValidationInfo,
    field_validator,
    model_validator,
)
from pydantic_core import core_schema


# for handling mongo ObjectIds
class PyObjectId(ObjectId):
    """
    Class for handling MongoDB document ObjectIds for 'id' fields in Models.
    """

    @classmethod
    def __get_pydantic_core_schema__(cls, source_type: Any, handler):
        return core_schema.union_schema(
            [
                # check if it's an instance first before doing any further work
                core_schema.is_instance_schema(ObjectId),
                core_schema.no_info_plain_validator_function(cls.validate),
            ],
            serialization=core_schema.to_string_ser_schema(),
        )

    @classmethod
    def validate(cls, v):
        if not ObjectId.is_valid(v):
            raise ValueError("Invalid ObjectId")
        return ObjectId(v)

    @classmethod
    def __get_pydantic_json_schema__(cls, field_schema):
        field_schema.update(type="string")


class Roles(BaseModel):
    """
    Model for storing a member's roles within the same club

    Attributes:
        rid (str): Unique Identifier for a role, a role id, it is
                   autogenerated. Defaults to None.
        name (str): Name of the role
        start_my (List[int]): Start date as [month, year]
        end_my (Optional[List[int]]): End date as [month, year]. Defaults to
                        None.
        approved (bool): Whether the role is approved. Defaults to False.
        approval_time (Optional[str]): Time the role was approve. Defaults to
                                       None.
        rejected (bool): Whether the role was rejected. Defaults to False.
        rejection_time (Optional[str]): Time the role was rejected. Defaults
                                        to None.
        deleted (bool): Whether the role is deleted. Defaults to False.
    """

    rid: str | None = Field(None, description="Unique Identifier for a role")
    name: str = Field(..., min_length=1, max_length=99)
    start_my: List[int] = Field(..., description="Start [month, year]")
    end_my: List[int] | None = Field(
        None, description="End [month, year] or None if ongoing"
    )
    approved: bool = False
    approval_time: str | None = None
    rejected: bool = False
    rejection_time: str | None = None
    deleted: bool = False

    # Validators
    @model_validator(mode="after")
    def validate_dates(self):
        """
        Validate start and end dates
        """

        def check(v) -> list[int]:
            if not isinstance(v, list) or len(v) != 2:
                raise ValueError("format must be [month, year]")
            if not isinstance(v[0], int) or not 1 <= v[0] <= 12:
                raise ValueError("month must be between 1 and 12")
            if not isinstance(v[1], int) or not 2010 <= v[1] <= 2050:
                raise ValueError("year must be between 2010 and 2050")
            return v

        start_validated = check(self.start_my)

        end_validated = None
        if self.end_my is not None:
            end_validated = check(self.end_my)

        # If end < start, clear end
        if end_validated is not None:
            sm, sy = start_validated[0], start_validated[1]
            em, ey = end_validated[0], end_validated[1]
            if (ey, em) < (sy, sm):
                end_validated = None

        object.__setattr__(self, "start_my", start_validated)
        object.__setattr__(self, "end_my", end_validated)

        return self

    @field_validator("rejected")
    def check_status(cls, value, info: ValidationInfo):
        """
        Validates status of the role
        """
        if info.data["approved"] is True and value is True:
            raise ValueError("Role cannot be both approved and rejected")
        return value

    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        str_max_length=100,
        validate_assignment=True,
        validate_default=True,
        validate_return=True,
        extra="forbid",
        str_strip_whitespace=True,
    )


class Member(BaseModel):
    """
    Model for storing a club member's information

    Attributes:
        id (PyObjectId): Stores the ObjectId of the member's document.
        cid (str): club id.
        uid (str): user id.
        creation_time (str): Time the member was created. Defaults to None.
        last_edited_time (str): Time the member's information was last edited.
                                Defaults to None.
        roles (List[Roles]): List of Roles of the member in this club.
        poc (bool): Whether the member is a POC(Point of Contact) for the
                    club.
    """

    id: PyObjectId = Field(default_factory=PyObjectId, alias="_id")
    cid: str = Field(..., description="Club ID")
    uid: str = Field(..., description="User ID")
    creation_time: str | None = None
    last_edited_time: str | None = None
    roles: List[Roles] = Field(
        ..., description="List of Roles for that specific person"
    )

    poc: bool = Field(default_factory=(lambda: 0 == 1), description="Club POC")

    @field_validator("uid", mode="before")
    @classmethod
    def transform_uid(cls, v):
        return v.lower()

    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        str_strip_whitespace=True,
        str_max_length=600,
        validate_assignment=True,
        validate_default=True,
        validate_return=True,
        extra="forbid",
        populate_by_name=True,
    )

    # Separate Coordinator & other members roles option in frontend,
    # for better filtering for all_members_query
